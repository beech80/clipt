import React, { useEffect, useState, useRef, useCallback } from 'react';
import SuspenseBoundary from '@/components/common/SuspenseBoundary';
import { LoadingFallback } from '@/components/ui/LoadingStates';
import { WifiOff, RefreshCw, AlertCircle } from 'lucide-react';

interface VideoProxyProps {
  src: string;
  className?: string;
  controls?: boolean;
  autoPlay?: boolean;
  muted?: boolean;
  loop?: boolean;
  playsInline?: boolean;
  onError?: (error?: any) => void;
  onLoad?: () => void;
  preferredQuality?: 'auto' | 'low' | 'medium' | 'high';
  preload?: 'none' | 'metadata' | 'auto';
  disableAdaptiveStreaming?: boolean;
  retry?: boolean;
}

/**
 * VideoProxy component that handles proxying video content to bypass CORS and MIME type issues
 * Now includes bandwidth detection, adaptive quality, and improved error recovery
 */
const VideoProxy: React.FC<VideoProxyProps> = ({
  src,
  className = '',
  controls = true,
  autoPlay = true,
  muted = true,
  loop = true,
  playsInline = true,
  onError,
  onLoad,
  preferredQuality = 'auto',
  preload = 'auto',
  disableAdaptiveStreaming = false,
  retry = true,
}) => {
  // State declarations
  const [blobUrl, setBlobUrl] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const [showPlayButton, setShowPlayButton] = useState(false);
  const [bandwidth, setBandwidth] = useState<number | null>(null);
  const [connectionQuality, setConnectionQuality] = useState<'offline' | 'low' | 'medium' | 'high'>('medium');
  const [videoQuality, setVideoQuality] = useState<'low' | 'medium' | 'high'>(
    preferredQuality === 'auto' ? 'medium' : preferredQuality as any
  );
  const [isRetrying, setIsRetrying] = useState(false);
  const [failedAttempts, setFailedAttempts] = useState(0);
  
  // Refs
  const videoRef = useRef<HTMLVideoElement>(null);
  const networkCheckRef = useRef<number | null>(null);
  const lastErrorRef = useRef<any>(null);

  // Check network quality and set appropriate video quality
  const checkNetworkQuality = useCallback(async () => {
    try {
      setIsRetrying(true);
      console.log('VideoProxy: Checking network quality...');
      
      // Simple bandwidth detection - download a test file and measure speed
      const startTime = Date.now();
      const testFileUrl = 'https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js';
      const response = await fetch(testFileUrl, { cache: 'no-store' });
      
      if (!response.ok) {
        console.warn('Network quality check failed: unable to fetch test file');
        setConnectionQuality('offline');
        setIsRetrying(false);
        return;
      }
      
      const blob = await response.blob();
      const endTime = Date.now();
      
      // Calculate bandwidth in bits per second
      const fileSizeBits = blob.size * 8;
      const durationSeconds = (endTime - startTime) / 1000;
      const speedBps = fileSizeBits / durationSeconds;
      
      console.log(`VideoProxy: Network speed detected: ${speedBps / 1000000} Mbps`);
      setBandwidth(speedBps);
      
      // Set connection quality based on bandwidth
      if (speedBps > 3000000) { // 3 Mbps
        setConnectionQuality('high');
        if (preferredQuality === 'auto') setVideoQuality('high');
      } else if (speedBps > 800000) { // 800 Kbps
        setConnectionQuality('medium');
        if (preferredQuality === 'auto') setVideoQuality('medium');
      } else if (speedBps > 200000) { // 200 Kbps
        setConnectionQuality('low');
        if (preferredQuality === 'auto') setVideoQuality('low');
      } else {
        setConnectionQuality('offline');
        if (preferredQuality === 'auto') setVideoQuality('low');
      }
      
      setIsRetrying(false);
    } catch (error) {
      console.error('Network quality check failed:', error);
      setConnectionQuality('offline');
      setIsRetrying(false);
    }
  }, [preferredQuality]);

  // Exponential backoff for retries
  const getBackoffTime = useCallback((attempt: number) => {
    return Math.min(1000 * Math.pow(2, attempt), 30000); // Max 30 seconds
  }, []);

  // Handle retry button click with smart retry logic
  const retryFetch = useCallback(() => {
    setIsRetrying(true);
    setError(null);
    
    // Check network quality before trying again
    checkNetworkQuality().then(() => {
      console.log(`VideoProxy: Retrying with connection quality: ${connectionQuality}`);
      
      // Lower quality if we've had multiple failures
      if (failedAttempts > 1 && videoQuality !== 'low' && preferredQuality === 'auto') {
        console.log('VideoProxy: Multiple failures detected, reducing quality');
        setVideoQuality('low');
      }
      
      // Apply exponential backoff timing
      const backoffTime = getBackoffTime(failedAttempts);
      console.log(`VideoProxy: Applying backoff of ${backoffTime}ms before retry`);
      
      setTimeout(() => {
        setRetryCount(prev => prev + 1);
        setIsRetrying(false);
      }, backoffTime);
    });
  }, [checkNetworkQuality, connectionQuality, failedAttempts, getBackoffTime, preferredQuality, videoQuality]);

  // User interaction handler to help with autoplay
  const handleUserInteraction = useCallback(() => {
    if (videoRef.current && videoRef.current.paused && autoPlay) {
      const playPromise = videoRef.current.play();
      if (playPromise !== undefined) {
        playPromise.catch(error => {
          console.log('Auto-play prevented in VideoProxy:', error);
          setShowPlayButton(true);
        });
      }
    }
  }, [autoPlay]);

  // Fetch and create a blob URL from the source
  useEffect(() => {
    if (!src) {
      setError('No video source provided');
      setIsLoading(false);
      if (onError) onError(new Error('No video source provided'));
      return;
    }
    
    // Check network quality on first load
    if (!disableAdaptiveStreaming) {
      checkNetworkQuality();
    }

    let isMounted = true;
    const controller = new AbortController();
    const signal = controller.signal;

    // More aggressive video fetching with different approaches
    const fetchVideo = async () => {
      try {
        setIsLoading(true);
        setError(null);

        console.log(`VideoProxy: Fetching video from ${src}, attempt ${retryCount + 1}, quality: ${videoQuality}`);
        
        // If we detect slow connection, inform the user
        if (connectionQuality === 'low' && retryCount === 0) {
          console.log('VideoProxy: Low bandwidth detected, adapting quality...');
        }
        
        // First try direct URL approach
        if (retryCount === 0) {
          console.log('VideoProxy: Trying direct video element approach first');
          // This approach doesn't fetch the video blob, but just sets the src directly
          // This often works better for videos hosted on the same domain or CDNs
          setBlobUrl(src);
          setIsLoading(false);
          return; // Early return, we'll retry with other methods if this fails
        }
        
        // Second attempt: try with regular fetch
        if (retryCount === 1) {
          console.log('VideoProxy: Trying regular fetch approach');
          try {
            const response = await fetch(src, { 
              signal,
              cache: 'no-store'
            });
            
            if (!isMounted) return;
            
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const blob = await response.blob();
            if (!isMounted) return;
            
            let mimeType = response.headers.get('content-type');
            // Use more robust MIME type detection
            if (!mimeType || mimeType === 'text/plain' || mimeType === 'application/octet-stream') {
              if (src.toLowerCase().endsWith('.mp4')) {
                mimeType = 'video/mp4';
              } else if (src.toLowerCase().endsWith('.webm')) {
                mimeType = 'video/webm';
              } else if (src.toLowerCase().endsWith('.m3u8')) {
                mimeType = 'application/x-mpegURL';
              } else {
                mimeType = 'video/mp4'; // Default
              }
            }
            
            const videoBlob = new Blob([blob], { type: mimeType });
            const url = URL.createObjectURL(videoBlob);
            
            console.log(`VideoProxy: Created blob URL with MIME type ${mimeType}`);
            setBlobUrl(url);
            setIsLoading(false);
            if (onLoad) onLoad();
            return;
          } catch (fetchErr) {
            console.warn('Regular fetch failed, trying no-cors approach:', fetchErr);
            // Continue to next approach
          }
        }
        
        // Third attempt: try with no-cors mode
        if (retryCount >= 2) {
          console.log('VideoProxy: Trying no-cors fetch approach');
          try {
            const response = await fetch(src, { 
              signal,
              mode: 'no-cors',
              cache: 'no-store'
            });
            
            if (!isMounted) return;
            
            // Since no-cors doesn't let us read response, we create a default blob
            const videoBlob = new Blob([], { type: 'video/mp4' });
            const url = URL.createObjectURL(videoBlob);
            
            setBlobUrl(url);
            setIsLoading(false);
            if (onLoad) onLoad();
            return;
          } catch (fetchErr) {
            console.error('No-cors fetch failed:', fetchErr);
            setError('Video source could not be loaded. Please try again.');
            setIsLoading(false);
            setFailedAttempts(prev => prev + 1);
            if (onError) onError(fetchErr);
          }
        }
      } catch (error) {
        console.error('Error in video fetch process:', error);
        setError('Failed to load video. Please try again.');
        setIsLoading(false);
        
        if (blobUrl) {
          URL.revokeObjectURL(blobUrl);
        }
        
        lastErrorRef.current = error;
        setFailedAttempts(prev => prev + 1);
        
        if (onError) onError(error);
      }
    };

    fetchVideo();

    // Set up user interaction listener
    document.addEventListener('click', handleUserInteraction);
    document.addEventListener('touchstart', handleUserInteraction);

    return () => {
      isMounted = false;
      controller.abort();
      
      document.removeEventListener('click', handleUserInteraction);
      document.removeEventListener('touchstart', handleUserInteraction);
      
      // Clean up blob URL when component unmounts
      if (blobUrl) {
        URL.revokeObjectURL(blobUrl);
      }
      
      if (networkCheckRef.current) {
        clearInterval(networkCheckRef.current);
      }
    };
  }, [checkNetworkQuality, connectionQuality, disableAdaptiveStreaming, handleUserInteraction, onError, onLoad, retryCount, src, videoQuality]);
  
  // Set up periodic network quality checks
  useEffect(() => {
    if (!disableAdaptiveStreaming) {
      networkCheckRef.current = window.setInterval(() => {
        if (!isLoading && !error) {
          checkNetworkQuality();
        }
      }, 60000); // Check every minute
      
      return () => {
        if (networkCheckRef.current) {
          clearInterval(networkCheckRef.current);
        }
      };
    }
  }, [checkNetworkQuality, disableAdaptiveStreaming, error, isLoading]);

  return (
    <SuspenseBoundary 
      loadingMessage="Loading video..." 
      errorMessage={error || "Video playback error"}
      loadingVariant="pulse"
    >
      <div className="relative w-full h-full">
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/50 z-10">
            <div className="flex flex-col items-center">
              <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-white mb-4"></div>
              <p className="text-white">Loading video{connectionQuality === 'low' ? ' (low bandwidth detected)' : ''}...</p>
            </div>
          </div>
        )}
        
        {connectionQuality === 'low' && !isLoading && !error && (
          <div className="absolute top-2 right-2 bg-black/50 text-white text-xs rounded px-2 py-1 flex items-center z-10">
            <WifiOff className="w-3 h-3 mr-1" />
            Low bandwidth
          </div>
        )}
        
        {error && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/50 p-4 z-10">
            <AlertCircle className="w-12 h-12 text-red-500 mb-4" />
            <p className="text-white bg-red-700 px-3 py-1 rounded mb-4">{error}</p>
            <button 
              onClick={retryFetch} 
              className="px-4 py-2 bg-purple-700 hover:bg-purple-600 rounded text-white font-medium flex items-center"
              disabled={isRetrying}
            >
              {isRetrying ? 'Retrying...' : 'Try Again'} 
              {isRetrying && <RefreshCw className="ml-2 w-4 h-4 animate-spin" />}
            </button>
          </div>
        )}
        
        {blobUrl && (
          <video
            ref={videoRef}
            src={blobUrl}
            className={className}
            controls={controls}
            autoPlay={autoPlay}
            muted={muted}
            loop={loop}
            playsInline={playsInline}
            preload={preload}
            onError={(e) => {
              const videoElement = e.target as HTMLVideoElement;
              console.error('Video element error in VideoProxy:', {
                errorCode: videoElement.error?.code,
                errorMessage: videoElement.error?.message,
                networkState: videoElement.networkState,
                readyState: videoElement.readyState
              });
              
              if (retryCount < 5) {
                console.log(`Video element error, retrying (${retryCount}/5)`);
                setRetryCount(prev => prev + 1);
              } else if (onError) {
                onError(videoElement.error);
              }
            }}
            onLoadedData={() => {
              console.log('Video loaded successfully');
              setIsLoading(false);
              setError(null);
              if (onLoad) onLoad();
              // Force play for mobile devices which sometimes need user interaction
              if (videoRef.current && autoPlay) {
                const playPromise = videoRef.current.play();
                if (playPromise !== undefined) {
                  playPromise.then(() => {
                    setShowPlayButton(false);
                  }).catch(err => {
                    console.log('Auto-play prevented in VideoProxy. User interaction needed:', err);
                    setShowPlayButton(true);
                  });
                }
              }
            }}
            onPlay={() => setShowPlayButton(false)}
            style={{ width: '100%', height: '100%', objectFit: 'cover', maxHeight: '90vh' }}
          />
        )}
        
        {/* Manual play button overlay for browsers that block autoplay */}
        {showPlayButton && !isLoading && blobUrl && (
          <div 
            className="absolute inset-0 flex items-center justify-center bg-black/40 cursor-pointer z-10"
            onClick={() => {
              if (videoRef.current) {
                videoRef.current.play()
                  .then(() => setShowPlayButton(false))
                  .catch(err => console.error("Manual play failed:", err));
              }
            }}
          >
            <div className="bg-purple-700/80 p-4 rounded-full hover:bg-purple-600 transition-colors">
              <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="white">
                <path d="M8 5v14l11-7z"/>
              </svg>
            </div>
          </div>
        )}
      </div>
    </SuspenseBoundary>
  );
};

export default VideoProxy;
